/*
  # MCP Integration and Subagent Execution Layer
  
  ## Overview
  This migration creates the infrastructure for integrating the Six Sigma MCP server
  with the web application, including subagent execution tracking and operation history.
  
  ## New Tables
  
  ### 1. `mcp_operations`
  Tracks all MCP server operations and their results
  - `id` (uuid, primary key) - Unique operation identifier
  - `project_id` (uuid) - Links to projects
  - `operation_type` (text) - Type of operation (create_project/define_phase/measure_phase/etc)
  - `phase` (text) - DMAIC phase if applicable
  - `input_data` (jsonb) - Input parameters sent to MCP
  - `output_data` (jsonb) - Results returned from MCP
  - `status` (text) - pending/running/completed/failed
  - `started_at` (timestamptz) - When operation started
  - `completed_at` (timestamptz) - When operation finished
  - `error_message` (text) - Error details if failed
  - `triggered_by` (uuid) - User who triggered the operation
  - `created_at` (timestamptz)
  
  ### 2. `subagent_executions`
  Tracks individual subagent executions from the enhanced MCP server
  - `id` (uuid, primary key) - Unique execution identifier
  - `mcp_operation_id` (uuid) - Links to mcp_operations
  - `project_id` (uuid) - Links to projects
  - `agent_type` (text) - Type of subagent (performance-test-engineer/bug-triage-specialist/etc)
  - `agent_role` (text) - Agent role description
  - `phase` (text) - DMAIC phase
  - `task_description` (text) - What the agent is tasked to do
  - `capabilities` (text[]) - Agent capabilities
  - `status` (text) - queued/running/completed/failed
  - `input_data` (jsonb) - Input data for the agent
  - `output_data` (jsonb) - Results from the agent
  - `metrics` (jsonb) - Performance metrics if applicable
  - `findings` (jsonb) - Bugs, issues, or insights found
  - `recommendations` (text[]) - Agent recommendations
  - `started_at` (timestamptz)
  - `completed_at` (timestamptz)
  - `duration_ms` (integer) - Execution duration in milliseconds
  - `created_at` (timestamptz)
  
  ### 3. `mcp_artifacts`
  Stores artifacts generated by MCP operations
  - `id` (uuid, primary key)
  - `mcp_operation_id` (uuid) - Links to mcp_operations
  - `project_id` (uuid) - Links to projects
  - `artifact_type` (text) - voc_analysis/ctq_tree/fmea/solution/etc
  - `artifact_name` (text) - Human-readable name
  - `artifact_data` (jsonb) - Actual artifact content
  - `phase` (text) - DMAIC phase
  - `created_by_agent` (text) - Which agent/tool created it
  - `created_at` (timestamptz)
  
  ### 4. `quality_metrics_history`
  Historical tracking of quality metrics over time
  - `id` (uuid, primary key)
  - `project_id` (uuid) - Links to projects
  - `quality_score` (numeric) - Quality score at this point
  - `risk_level` (text) - Risk level at this point
  - `phase_completion` (numeric) - Phase completion percentage
  - `phase` (text) - Current phase
  - `kpi_scores` (jsonb) - KPI measurements
  - `recorded_at` (timestamptz) - When metrics were recorded
  
  ### 5. `project_templates`
  Reusable project templates for common scenarios
  - `id` (uuid, primary key)
  - `name` (text) - Template name
  - `description` (text) - Template description
  - `category` (text) - Template category (api/ui/infrastructure/etc)
  - `template_data` (jsonb) - Template configuration
  - `requirements_template` (text[]) - Default requirements
  - `ctq_template` (jsonb) - Default CTQ items
  - `tags` (text[]) - Template tags
  - `usage_count` (integer) - How many times used
  - `created_by` (uuid) - User who created template
  - `organization_id` (uuid) - Organization that owns template
  - `is_public` (boolean) - Whether template is public
  - `created_at` (timestamptz)
  - `updated_at` (timestamptz)
  
  ## Security
  
  - Row Level Security enabled on all tables
  - MCP operations visible to project members
  - Templates can be organization-private or public
  
  ## Notes
  
  - MCP operations provide audit trail of all automation
  - Subagent executions enable detailed monitoring
  - Metrics history enables trend analysis
  - Templates accelerate project creation
*/

-- Create mcp_operations table
CREATE TABLE IF NOT EXISTS mcp_operations (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id uuid REFERENCES projects(id) ON DELETE CASCADE,
  operation_type text NOT NULL,
  phase text CHECK (phase IN ('DEFINE', 'MEASURE', 'ANALYZE', 'IMPROVE', 'CONTROL')),
  input_data jsonb DEFAULT '{}',
  output_data jsonb DEFAULT '{}',
  status text DEFAULT 'pending' CHECK (status IN ('pending', 'running', 'completed', 'failed')),
  started_at timestamptz,
  completed_at timestamptz,
  error_message text,
  triggered_by uuid REFERENCES profiles(id) ON DELETE SET NULL,
  created_at timestamptz DEFAULT now()
);

-- Create subagent_executions table
CREATE TABLE IF NOT EXISTS subagent_executions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  mcp_operation_id uuid REFERENCES mcp_operations(id) ON DELETE CASCADE,
  project_id uuid REFERENCES projects(id) ON DELETE CASCADE,
  agent_type text NOT NULL,
  agent_role text NOT NULL,
  phase text NOT NULL CHECK (phase IN ('DEFINE', 'MEASURE', 'ANALYZE', 'IMPROVE', 'CONTROL')),
  task_description text NOT NULL,
  capabilities text[] DEFAULT '{}',
  status text DEFAULT 'queued' CHECK (status IN ('queued', 'running', 'completed', 'failed', 'cancelled')),
  input_data jsonb DEFAULT '{}',
  output_data jsonb DEFAULT '{}',
  metrics jsonb DEFAULT '{}',
  findings jsonb DEFAULT '{}',
  recommendations text[] DEFAULT '{}',
  started_at timestamptz,
  completed_at timestamptz,
  duration_ms integer,
  created_at timestamptz DEFAULT now()
);

-- Create mcp_artifacts table
CREATE TABLE IF NOT EXISTS mcp_artifacts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  mcp_operation_id uuid REFERENCES mcp_operations(id) ON DELETE CASCADE,
  project_id uuid REFERENCES projects(id) ON DELETE CASCADE,
  artifact_type text NOT NULL,
  artifact_name text NOT NULL,
  artifact_data jsonb NOT NULL DEFAULT '{}',
  phase text NOT NULL CHECK (phase IN ('DEFINE', 'MEASURE', 'ANALYZE', 'IMPROVE', 'CONTROL')),
  created_by_agent text,
  created_at timestamptz DEFAULT now()
);

-- Create quality_metrics_history table
CREATE TABLE IF NOT EXISTS quality_metrics_history (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id uuid NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  quality_score numeric NOT NULL,
  risk_level text NOT NULL CHECK (risk_level IN ('LOW', 'MEDIUM', 'HIGH')),
  phase_completion numeric NOT NULL,
  phase text NOT NULL CHECK (phase IN ('DEFINE', 'MEASURE', 'ANALYZE', 'IMPROVE', 'CONTROL', 'COMPLETED')),
  kpi_scores jsonb DEFAULT '{}',
  recorded_at timestamptz DEFAULT now()
);

-- Create project_templates table
CREATE TABLE IF NOT EXISTS project_templates (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  description text NOT NULL,
  category text NOT NULL,
  template_data jsonb DEFAULT '{}',
  requirements_template text[] DEFAULT '{}',
  ctq_template jsonb DEFAULT '{}',
  tags text[] DEFAULT '{}',
  usage_count integer DEFAULT 0,
  created_by uuid REFERENCES profiles(id) ON DELETE SET NULL,
  organization_id uuid REFERENCES organizations(id) ON DELETE CASCADE,
  is_public boolean DEFAULT false,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_mcp_operations_project_id ON mcp_operations(project_id);
CREATE INDEX IF NOT EXISTS idx_mcp_operations_status ON mcp_operations(status);
CREATE INDEX IF NOT EXISTS idx_mcp_operations_triggered_by ON mcp_operations(triggered_by);
CREATE INDEX IF NOT EXISTS idx_subagent_executions_mcp_operation_id ON subagent_executions(mcp_operation_id);
CREATE INDEX IF NOT EXISTS idx_subagent_executions_project_id ON subagent_executions(project_id);
CREATE INDEX IF NOT EXISTS idx_subagent_executions_status ON subagent_executions(status);
CREATE INDEX IF NOT EXISTS idx_subagent_executions_agent_type ON subagent_executions(agent_type);
CREATE INDEX IF NOT EXISTS idx_mcp_artifacts_project_id ON mcp_artifacts(project_id);
CREATE INDEX IF NOT EXISTS idx_mcp_artifacts_operation_id ON mcp_artifacts(mcp_operation_id);
CREATE INDEX IF NOT EXISTS idx_quality_metrics_history_project_id ON quality_metrics_history(project_id);
CREATE INDEX IF NOT EXISTS idx_quality_metrics_history_recorded_at ON quality_metrics_history(recorded_at);
CREATE INDEX IF NOT EXISTS idx_project_templates_organization_id ON project_templates(organization_id);
CREATE INDEX IF NOT EXISTS idx_project_templates_category ON project_templates(category);
CREATE INDEX IF NOT EXISTS idx_project_templates_is_public ON project_templates(is_public);

-- Enable Row Level Security
ALTER TABLE mcp_operations ENABLE ROW LEVEL SECURITY;
ALTER TABLE subagent_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE mcp_artifacts ENABLE ROW LEVEL SECURITY;
ALTER TABLE quality_metrics_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE project_templates ENABLE ROW LEVEL SECURITY;

-- RLS Policies for mcp_operations
CREATE POLICY "Users can view mcp_operations for their org projects"
  ON mcp_operations FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM projects p
      JOIN organization_members om ON p.organization_id = om.organization_id
      WHERE p.id = mcp_operations.project_id
      AND om.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can create mcp_operations for their projects"
  ON mcp_operations FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM project_members pm
      WHERE pm.project_id = mcp_operations.project_id
      AND pm.user_id = auth.uid()
      AND pm.role IN ('owner', 'manager', 'contributor')
    )
    AND triggered_by = auth.uid()
  );

CREATE POLICY "Users can update their own mcp_operations"
  ON mcp_operations FOR UPDATE
  TO authenticated
  USING (triggered_by = auth.uid())
  WITH CHECK (triggered_by = auth.uid());

-- RLS Policies for subagent_executions
CREATE POLICY "Users can view subagent_executions for their org projects"
  ON subagent_executions FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM projects p
      JOIN organization_members om ON p.organization_id = om.organization_id
      WHERE p.id = subagent_executions.project_id
      AND om.user_id = auth.uid()
    )
  );

CREATE POLICY "System can manage subagent_executions"
  ON subagent_executions FOR ALL
  TO authenticated
  USING (true)
  WITH CHECK (true);

-- RLS Policies for mcp_artifacts
CREATE POLICY "Users can view mcp_artifacts for their org projects"
  ON mcp_artifacts FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM projects p
      JOIN organization_members om ON p.organization_id = om.organization_id
      WHERE p.id = mcp_artifacts.project_id
      AND om.user_id = auth.uid()
    )
  );

CREATE POLICY "System can create mcp_artifacts"
  ON mcp_artifacts FOR INSERT
  TO authenticated
  WITH CHECK (true);

-- RLS Policies for quality_metrics_history
CREATE POLICY "Users can view quality_metrics_history for their org projects"
  ON quality_metrics_history FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM projects p
      JOIN organization_members om ON p.organization_id = om.organization_id
      WHERE p.id = quality_metrics_history.project_id
      AND om.user_id = auth.uid()
    )
  );

CREATE POLICY "System can create quality_metrics_history"
  ON quality_metrics_history FOR INSERT
  TO authenticated
  WITH CHECK (true);

-- RLS Policies for project_templates
CREATE POLICY "Users can view public templates or their org templates"
  ON project_templates FOR SELECT
  TO authenticated
  USING (
    is_public = true
    OR organization_id IN (
      SELECT organization_id FROM organization_members
      WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can create templates in their organization"
  ON project_templates FOR INSERT
  TO authenticated
  WITH CHECK (
    organization_id IN (
      SELECT organization_id FROM organization_members
      WHERE user_id = auth.uid()
    )
    AND created_by = auth.uid()
  );

CREATE POLICY "Template creators can update their templates"
  ON project_templates FOR UPDATE
  TO authenticated
  USING (created_by = auth.uid())
  WITH CHECK (created_by = auth.uid());

CREATE POLICY "Template creators can delete their templates"
  ON project_templates FOR DELETE
  TO authenticated
  USING (created_by = auth.uid());

-- Function to automatically record quality metrics when project updates
CREATE OR REPLACE FUNCTION record_quality_metrics()
RETURNS TRIGGER AS $$
BEGIN
  IF OLD.quality_score IS DISTINCT FROM NEW.quality_score
     OR OLD.risk_level IS DISTINCT FROM NEW.risk_level
     OR OLD.phase_completion IS DISTINCT FROM NEW.phase_completion
     OR OLD.current_phase IS DISTINCT FROM NEW.current_phase THEN
    
    INSERT INTO quality_metrics_history (
      project_id,
      quality_score,
      risk_level,
      phase_completion,
      phase,
      recorded_at
    ) VALUES (
      NEW.id,
      NEW.quality_score,
      NEW.risk_level,
      NEW.phase_completion,
      NEW.current_phase,
      now()
    );
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to record quality metrics on project updates
DROP TRIGGER IF EXISTS on_project_quality_change ON projects;
CREATE TRIGGER on_project_quality_change
  AFTER UPDATE ON projects
  FOR EACH ROW
  EXECUTE FUNCTION record_quality_metrics();

-- Function to calculate subagent execution duration
CREATE OR REPLACE FUNCTION calculate_subagent_duration()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.completed_at IS NOT NULL AND NEW.started_at IS NOT NULL THEN
    NEW.duration_ms := EXTRACT(EPOCH FROM (NEW.completed_at - NEW.started_at)) * 1000;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to calculate duration before insert/update
DROP TRIGGER IF EXISTS calculate_subagent_duration_trigger ON subagent_executions;
CREATE TRIGGER calculate_subagent_duration_trigger
  BEFORE INSERT OR UPDATE ON subagent_executions
  FOR EACH ROW
  EXECUTE FUNCTION calculate_subagent_duration();

-- Create trigger for updated_at on templates
CREATE TRIGGER update_project_templates_updated_at
  BEFORE UPDATE ON project_templates
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();